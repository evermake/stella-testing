import path from "node:path"
import fs from "node:fs"
import { exec } from "node:child_process"
import { program } from "commander"
import { glob } from "glob"
import cliProgress from "cli-progress"
import type { Report, TestcaseConclusion } from "./types"

async function fileExists(path: string) {
  try {
    await fs.promises.access(path, fs.constants.F_OK)
    return true
  } catch (_) {
    return false
  }
}

export type ExpectedTypecheckResult =
  | { type: 'unknown' }
  | { type: 'ok' }
  | {
    type: 'type-error'
    primaryTags: string[]
    alternativeTags: string[]
  }

const ERROR_TAG_REGEX = /\[(ERROR_\w+)\]/g
const TYPE_ERROR_OUTPUT_WITH_PRIMARY_AND_ALTERNATIVE_ERRORS_REGEX = /^An error occurred during typechecking!\s+===================\s*Primary type error:\s*===================([\S\s]+)========================\s*Alternative type errors:\s*========================([\S\s]+)$/

function parseExpectedTypecheckResultFromOutput(out: string): ExpectedTypecheckResult {
  out = out.trim()

  // Original typechecker returned nothing, therefore no type errors.
  if (out === "") {
    return { type: 'ok' }
  }

  if (!out.startsWith("An error occurred during typechecking")) {
    return { type: 'unknown' }
  }

  const primaryAndAlternativeErrorTagsMatch = TYPE_ERROR_OUTPUT_WITH_PRIMARY_AND_ALTERNATIVE_ERRORS_REGEX.exec(out)
  if (primaryAndAlternativeErrorTagsMatch) {
    const primaryTags = Array.from(primaryAndAlternativeErrorTagsMatch[1].matchAll(ERROR_TAG_REGEX), m => m[1])
    const alternativeTags = Array.from(primaryAndAlternativeErrorTagsMatch[2].matchAll(ERROR_TAG_REGEX), m => m[1])

    if (primaryTags.length === 0 || alternativeTags.length === 0) {
      return { type: 'unknown' }
    }

    return {
      type: 'type-error',
      primaryTags,
      alternativeTags,
    }
  }

  const errorTags = Array.from(out.matchAll(ERROR_TAG_REGEX), m => m[1])

  if (errorTags.length !== 1) {
    return { type: 'unknown' }
  }

  return {
    type: 'type-error',
    primaryTags: errorTags,
    alternativeTags: [],
  }
}

function getTestcaseConclusion(tc: {
  expectedOutput: string,
  actualOutput: string,
  actualExitCode: number,
}): TestcaseConclusion {
  const result = parseExpectedTypecheckResultFromOutput(tc.expectedOutput)
  switch (result.type) {
    case "ok":
      return tc.actualExitCode === 0 ? 'correct' : 'incorrect'
    case "type-error":
      if (result.primaryTags.some(tag => tc.actualOutput.includes(tag))) {
        return 'correct'
      } else if (result.alternativeTags.some(tag => tc.actualOutput.includes(tag))) {
        return 'partially-correct'
      } else {
        return 'incorrect'
      }
    case "unknown":
      return 'unknown'
  }
}

async function executeTypechecker(
  typecheckerPath: string,
  input: string,
): Promise<{ exitCode: number, stdout: string, stderr: string }> {
  return new Promise((resolve) => {
    const child = exec(`"${typecheckerPath}"`, (err, stdout, stderr) => {
      resolve({ exitCode: err?.code ?? 0, stdout, stderr })
    })

    if (!child.stdin) {
      throw new Error("child.stdin is null")
    }

    child.stdin.on('error', (err) => {
      console.error('Error writing to stdin of a process:', err)
    })

    child.stdin.write(input)
    child.stdin.end()
  })
}

async function main() {
  program
    .name('test-typechecker')
    .description('Test your Stella typechecker implementation against a set of .stella files and save the results to a JSON file.')
    //
    .argument('<tests-path>', 'path to directory with files to typecheck and .out files generated by correct Stella implementation')
    //
    .requiredOption('-t, --typechecker <path>', "path to the typechecker executable")
    .option('-o, --out <path>', "path where to save typechecker results", "./typechecker-report.json")
    //
    .parse()

  const [testsDir] = program.args
  const options = program.opts()
  const reportPath = path.resolve(options.out)
  const typecheckerPath = path.resolve(options.typechecker)

  const srcFilePaths = await glob(path.resolve(testsDir, "**/*.stella").replace(/\\/g,'/'))

  console.log(`Testing typechecker with ${srcFilePaths.length} Stella files...`)
  const bar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic);
  bar.start(srcFilePaths.length, 0);

  const report: Report = { testcases: {} }

  for (let i = 0; i < srcFilePaths.length; i++) {
    const srcFilePath = srcFilePaths[i]
    const outFilePath = srcFilePath.replace(/\.stella$/, ".stella.out")

    if (!(await fileExists(outFilePath))) {
      console.log(`No .stella.out file found for ${srcFilePath}, skipping...`)
      continue
    }

    const snippet = (await fs.promises.readFile(srcFilePath)).toString()
    const expectedOutput = (await fs.promises.readFile(outFilePath)).toString()
    const result = await executeTypechecker(typecheckerPath, snippet)
    const conclusion = getTestcaseConclusion({
      expectedOutput,
      actualOutput: `${result.stdout}\n${result.stderr}`,
      actualExitCode: result.exitCode,
    })

    const pathRelativeToTests = path.relative(testsDir, srcFilePath)

    report.testcases[pathRelativeToTests] = {
      conclusion,
      snippet,
      expected: expectedOutput,
      exitCode: result.exitCode,
      actualStdout: result.stdout,
      actualStderr: result.stderr,
    }

    if (conclusion === 'unknown') {
      console.log('')
      console.warn(`WARNING: unable to make conclusion for test "${pathRelativeToTests}"`)
    }

    bar.increment(1)
  }

  bar.stop()

  await fs.promises.writeFile(reportPath, JSON.stringify(report, null, 2))
}

main()
