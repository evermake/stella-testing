import path from "node:path"
import fs from "node:fs"
import { exec } from "node:child_process"
import { program } from "commander"
import { glob } from "glob"
import cliProgress from "cli-progress"
import type { Report } from "./types"

async function fileExists(path: string) {
  try {
    await fs.promises.access(path, fs.constants.F_OK)
    return true
  } catch (_) {
    return false
  }
}


const ERROR_TAG_REGEX = /\[(ERROR_(\w+))\]/i

function parseExpectedResult(expected: string): (
  | { ok: true }
  | { ok: null }
  | { ok: false; errorTag: string }
) {
  if (expected.trim() === "") {
    return { ok: true }
  }

  const typeErrorMatch = expected.match(ERROR_TAG_REGEX)

  if (typeErrorMatch) {
    return {
      ok: false,
      errorTag: typeErrorMatch[1],
    }
  }

  return { ok: null }
}

function getTestcaseConclusion(testcase: {
  expected: string,
  actualStdout: string,
  actualStderr: string,
  exitCode: number,
}): { passed: boolean | null } {
  const expectedResult = parseExpectedResult(testcase.expected)
  if (expectedResult.ok) {
    return { passed: testcase.exitCode === 0 }
  } else if (expectedResult.ok === null) {
    return { passed: null }
  } else {
    if (testcase.exitCode === 0) {
      return { passed: false }
    }

    const resultStr = `${testcase.actualStdout}\n${testcase.actualStderr}`

    return {
      passed: resultStr.includes(expectedResult.errorTag)
    }
  }
}

async function executeTypechecker(
  typecheckerPath: string,
  input: string,
): Promise<{ exitCode: number, stdout: string, stderr: string }> {
  return new Promise((resolve) => {
    const child = exec(typecheckerPath, (err, stdout, stderr) => {
      resolve({ exitCode: err?.code ?? 0, stdout, stderr })
    })

    if (!child.stdin) {
      throw new Error("child.stdin is null")
    }

    child.stdin.write(input)
    child.stdin.end()
  })
}

async function main() {
  program
    .name('test-typechecker')
    .description('Test your Stella typechecker implementation against a set of .stella files and save the results to a JSON file.')
    //
    .argument('<tests-path>', 'path to directory with files to typecheck and .out files generated by correct Stella implementation')
    //
    .requiredOption('-t, --typechecker <path>', "path to the typechecker executable")
    .option('-o, --out <path>', "path where to save typechecker results", "./typechecker-report.json")
    //
    .parse()

  const [testsDir] = program.args
  const options = program.opts()
  const reportPath = path.resolve(options.out)
  const typecheckerPath = path.resolve(options.typechecker)

  const srcFilePaths = await glob(path.resolve(testsDir, "**/*.stella"))

  console.log(`Testing typechecker with ${srcFilePaths.length} Stella files...`)
  const bar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic);
  bar.start(srcFilePaths.length, 0);

  const report: Report = { testcases: {} }

  for (let i = 0; i < srcFilePaths.length; i++) {
    const srcFilePath = srcFilePaths[i]
    const outFilePath = srcFilePath.replace(/\.stella$/, ".stella.out")

    if (!(await fileExists(outFilePath))) {
      console.log(`No .stella.out file found for ${srcFilePath}, skipping...`)
      continue
    }

    const snippet = (await fs.promises.readFile(srcFilePath)).toString()
    const expected = (await fs.promises.readFile(outFilePath)).toString()
    const result = await executeTypechecker(typecheckerPath, snippet)
    const conclusion = getTestcaseConclusion({
      expected,
      exitCode: result.exitCode,
      actualStdout: result.stdout,
      actualStderr: result.stderr,
    })

    const pathRelativeToTests = path.relative(testsDir, srcFilePath)

    report.testcases[pathRelativeToTests] = {
      passed: conclusion.passed,
      snippet,
      expected,
      exitCode: result.exitCode,
      actualStdout: result.stdout,
      actualStderr: result.stderr,
    }

    bar.increment(1)
  }

  bar.stop()

  await fs.promises.writeFile(reportPath, JSON.stringify(report, null, 2))
}

main()
